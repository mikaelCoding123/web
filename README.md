### 行锁升级到表锁的条件和场景

在数据库管理系统中，尤其是MySQL的InnoDB存储引擎，行锁和表锁是两种常见的锁类型。行锁针对特定的数据行，粒度较小，通常能提供更好的并发性能；而表锁则针对整个表，粒度较大，适用于需要锁定整个表的场景。在某些情况下，行锁可能会升级到表锁，以确保事务的正确执行和数据的一致性。以下是行锁升级到表锁的主要条件和场景：

#### 1. **全表扫描操作**

当一个事务需要对整个表进行扫描时，InnoDB可能会选择锁定整个表，而不是逐个锁定每一行。这种情况下，行锁会被升级到表锁，以简化锁管理并提高性能。

**示例场景：**

```sql
SELECT * FROM my_table;
```

在这种情况下，InnoDB可能会判断逐个锁定每一行的开销较高，选择锁定整个表，从而提高全表扫描的效率。

#### 2. **高并发下的锁竞争**

在高并发场景下，如果多个事务同时对同一表的不同行进行操作，可能会导致大量的行锁竞争。为了减少锁冲突和死锁的风险，InnoDB可能会选择将行锁升级到表锁，以降低锁管理的复杂性。

**示例场景：**

多个事务同时对`my_table`的不同行进行`UPDATE`操作，导致行锁竞争激烈。

```sql
UPDATE my_table SET column = value WHERE condition;
```

此时，InnoDB可能会升级到表锁，以减少锁冲突，提高系统整体性能。

#### 3. **特定的SQL操作**

某些SQL操作，如`DELETE`、`UPDATE`等，如果涉及范围较大的数据修改，可能会导致行锁升级到表锁，以确保操作的原子性和一致性。

**示例场景：**

执行一个范围较大的`UPDATE`操作，影响了表中的大量行。

```sql
UPDATE my_table SET column = value WHERE condition = 'large_range';
```

由于涉及的数据行较多，InnoDB可能会选择锁定整个表，以避免频繁的行锁操作和潜在的锁冲突。

#### 4. **锁升级的优化策略**

InnoDB可能会根据内部的优化策略，动态决定是否将行锁升级到表锁。例如，当检测到行锁的数量超过一定阈值时，可能会选择升级到表锁以提高系统性能。

**示例场景：**

系统检测到当前行锁的数量已达到预设的阈值，为避免进一步的锁竞争和性能下降，选择将行锁升级到表锁。

#### 5. **外键约束和级联操作**

在涉及外键约束和级联操作的情况下，InnoDB可能会将行锁升级到表锁，以确保外键关系的完整性和级联操作的正确执行。

**示例场景：**

删除一个主表中的记录，同时需要级联删除从表中的相关记录。

```sql
DELETE FROM parent_table WHERE id = 1;
```

由于外键约束的存在，InnoDB可能需要锁定相关表的整个表，以确保级联删除操作的原子性和一致性。

#### 6. **使用特定的存储引擎特性**

某些存储引擎特性可能会导致行锁升级到表锁。例如，在使用`MyISAM`存储引擎时，表锁是默认的锁机制，而在`InnoDB`中，虽然支持行锁，但在某些特定操作下，仍可能升级到表锁。

**示例场景：**

使用`MyISAM`存储引擎的表进行`SELECT`操作，导致表锁被锁定。

```sql
SELECT * FROM my_table;
```

由于`MyISAM`存储引擎默认使用表锁，因此在这种情况下，行锁无法应用，直接使用表锁。

#### 7. **系统配置和参数设置**

数据库的配置参数也可能影响锁的升级行为。例如，调整`innodb_locks_unsafe_for_binlog`参数的值，可能会影响InnoDB的锁策略。

**示例场景：**

调整`innodb_locks_unsafe_for_binlog`参数，允许InnoDB在某些情况下使用不安全的锁策略，从而可能导致行锁升级到表锁。

#### 8. **锁超时和死锁检测**

在锁超时或死锁检测机制触发时，InnoDB可能会选择升级锁级别，以解除死锁或避免长时间的锁等待。

**示例场景：**

两个事务相互等待对方释放锁，导致死锁。InnoDB检测到死锁后，可能会选择回滚其中一个事务，并升级锁级别以避免类似情况再次发生。

#### 9. **特定的存储引擎锁定模式**

某些存储引擎在特定模式下可能会强制使用表锁。例如，在使用`READ UNCOMMITTED`隔离级别时，某些操作可能会导致行锁升级到表锁。

**示例场景：**

在`READ UNCOMMITTED`隔离级别下执行`UPDATE`操作，导致行锁升级到表锁。

```sql
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
UPDATE my_table SET column = value WHERE condition;
```

由于隔离级别较低，InnoDB可能会选择使用表锁以简化锁管理。

#### 10. **数据库恢复和维护操作**

在数据库恢复、备份或维护操作期间，可能会锁定整个表或数据库，以确保操作的原子性和一致性。

**示例场景：**

执行数据库备份操作，锁定整个表以防止数据不一致。

```sql
FLUSH TABLES WITH READ LOCK;
```

此时，InnoDB会锁定整个表，以确保备份操作的完整性。

### 总结

行锁升级到表锁的情况通常发生在以下场景：

1. **全表扫描操作**：锁定整个表以提高全表扫描的效率。
2. **高并发下的锁竞争**：减少锁冲突和死锁的风险。
3. **特定的SQL操作**：涉及范围较大的数据修改，确保操作的原子性和一致性。
4. **锁升级的优化策略**：根据内部优化策略，动态调整锁级别。
5. **外键约束和级联操作**：确保外键关系的完整性和级联操作的正确执行。
6. **使用特定的存储引擎特性**：某些存储引擎默认使用表锁。
7. **系统配置和参数设置**：数据库配置参数影响锁策略。
8. **锁超时和死锁检测**：解除死锁或避免长时间锁等待。
9. **特定的存储引擎锁定模式**：某些隔离级别下强制使用表锁。
10. **数据库恢复和维护操作**：确保恢复和维护操作的原子性和一致性。

理解这些条件和场景，有助于更好地管理和优化数据库的锁机制，提升系统的整体性能和稳定性。在实际应用中，合理配置事务隔离级别和锁策略，可以有效避免不必要的锁升级，减少锁冲突，提高系统的并发处理能力。
















https://www.yuque.com/panda-expert/myjava/aee9gck90nunrdnc

https://www.yuque.com/skyming/java/ccr6xn  多线程
https://juejin.cn/post/7384353917750689819   aqs源码


https://blog.csdn.net/qq_37205350/article/details/114546532  索引失效原理你真的懂了吗？


https://blog.nowcoder.net/n/e4c2e6a497894737aab23474840e6fe9  腾讯面试题：有了二叉查找树、平衡树为啥还需要红黑树？


https://developer.aliyun.com/article/56927   spring事务跟mysql事务

https://www.cnblogs.com/chanshuyi/p/head-first-of-spring-transaction.html   spring事务

批量查询接口

分片算法优化
deepwiki
https://juejin.cn/post/6964531365643550751

https://www.bilibili.com/video/BV1AJrzYZEtw

父类静态属性（成员变量） > 父类静态代码块 > 子类静态属性 > 子类静态代码块 > 父类非静态属性 > 父类非静态代码块 > 父类构造器 > 子类非静态属性 > 子类非静态代码块 > 子类构造器


取月光二两
二两月色

十四行诗与月亮
59dbad8f0a59757fb5435c2d069a53090ad68746
iks


{{
  "traceId": "8ef83e554afa4172a703bf53e71bcf7e",
  "code": null,
  "msg": "操作成功",
  "data": "success"
}
}

===========================
### 数据库事务的实现原理

数据库事务是确保数据库操作一致性和完整性的机制，其实现依赖于日志文件和锁机制，并遵循ACID特性（原子性、一致性、隔离性和持久性）。以下是事务实现的详细步骤：

1. **事务的开始**：
   - 当一个事务开始时，数据库管理系统（DBMS）创建一个事务上下文，记录该事务的所有操作。
   - 所有后续的数据库操作都会被标记为属于当前事务。

2. **日志记录**：
   - 每个事务的操作都会被记录到日志文件中。日志文件通常包括以下内容：
     - 事务的开始和结束标记。
     - 每个操作的详细信息，包括修改的数据、修改前后的值等。
     - 事务的提交或回滚标记。
   - 日志文件的作用是确保事务的原子性和持久性。即使在事务提交后，系统发生故障，日志文件也能帮助恢复事务。

3. **数据修改**：
   - 在事务执行过程中，所有对数据的修改都会被记录到日志文件中，但不会立即写入到数据库的数据文件中。
   - 数据库通常使用缓冲区来提高性能，将修改后的数据暂存在内存中，而不是立即写入磁盘。

4. **事务的提交**：
   - 当事务提交时，DBMS会将日志文件中的所有修改写入到数据库的数据文件中，确保数据的持久性。
   - 提交操作通常包括以下步骤：
     - 将日志文件中的修改标记为“已提交”。
     - 将缓冲区中的数据写入到磁盘，确保数据的持久性。
     - 释放事务占用的锁，允许其他事务访问被修改的数据。

5. **事务的回滚**：
   - 如果事务在执行过程中发生错误或被显式回滚，DBMS会根据日志文件回滚事务，撤销所有未提交的操作。
   - 回滚操作包括以下步骤：
     - 根据日志文件，恢复所有被修改的数据到事务开始前的状态。
     - 释放事务占用的锁，允许其他事务访问被修改的数据。

6. **锁机制**：
   - 为了确保事务的隔离性，DBMS使用锁机制来控制多个事务对同一数据的访问。
   - 常见的锁类型包括：
     - **共享锁（S锁）**：允许多个事务同时读取同一数据，但阻止其他事务修改该数据。
     - **排他锁（X锁）**：阻止其他事务读取或修改同一数据，确保事务的独占访问。
   - 锁的粒度可以是行锁（锁定单个数据行）或表锁（锁定整个数据表），不同的锁粒度会影响系统的并发性能和锁冲突的发生。

7. **并发控制**：
   - DBMS需要处理多个事务同时访问和修改数据的情况，确保事务的隔离性和一致性。
   - 常见的并发控制策略包括：
     - **乐观并发控制**：假设事务之间不会发生冲突，允许多个事务同时访问和修改数据。在提交时检查是否有冲突，如果有，则回滚其中一个事务。
     - **悲观并发控制**：假设事务之间会发生冲突，在事务开始时锁定数据，防止其他事务同时修改同一数据。这可以确保事务的隔离性，但可能会降低系统的并发性能。

8. **死锁处理**：
   - 在使用锁机制时，可能会发生死锁，即两个或多个事务互相等待对方释放锁，导致都无法继续执行。
   - DBMS通常采用预防和检测机制来处理死锁：
     - **死锁预防**：通过限制事务的锁顺序或使用其他策略，防止死锁的发生。
     - **死锁检测**：周期性检查系统中是否存在死锁，如果检测到死锁，则选择一个或多个事务回滚，以解除死锁状态。

9. **恢复机制**：
   - 在系统故障或崩溃时，DBMS需要根据日志文件恢复事务，确保数据的完整性和一致性。
   - 恢复机制通常包括以下步骤：
     - **前滚（Redo）**：将日志文件中已经提交但尚未写入数据文件的事务重新执行，确保数据的持久性。
     - **后滚（Undo）**：将日志文件中未提交的事务回滚，撤销所有未提交的操作，确保事务的原子性。

### 总结


### MySQL中的事务级别与间隙锁、行锁、表锁的关系

在MySQL中，事务级别和锁机制是紧密相关的，它们共同决定了数据库的并发控制和数据一致性。以下是事务级别与间隙锁、行锁、表锁之间关系的详细说明：

#### 1. **事务级别概述**

MySQL支持四种事务隔离级别：

- **读未提交（READ UNCOMMITTED）**
- **读已提交（READ COMMITTED）**
- **可重复读（REPEATABLE READ）**
- **串行化（SERIALIZABLE）**

每个隔离级别定义了事务之间如何共享和访问数据，从而影响锁的使用策略。

#### 2. **锁机制概述**

MySQL中的锁机制主要有三种：

- **间隙锁（Gap Locks）**：锁定索引中的一个范围（间隙），防止其他事务在该范围内插入新的记录。
- **行锁（Row Locks）**：锁定特定的记录（行），防止其他事务修改同一行数据。
- **表锁（Table Locks）**：锁定整个表，阻止其他事务对表进行修改。

#### 3. **事务级别与锁机制的关系**

##### **3.1 读未提交（READ UNCOMMITTED）**

- **锁使用**：不使用间隙锁，行锁和表锁的使用较少。
- **行为**：允许脏读、不可重复读和幻读，因为没有锁机制来隔离事务。
- **适用场景**：适用于对数据一致性要求较低的场景，追求高并发性能。

##### **3.2 读已提交（READ COMMITTED）**

- **锁使用**：使用行锁和表锁，间隙锁的使用可以禁用。
- **行为**：允许不可重复读和幻读，但不允许脏读。
- **适用场景**：适用于大多数在线事务处理（OLTP）应用，平衡数据一致性和性能。

##### **3.3 可重复读（REPEATABLE READ）**

- **锁使用**：默认使用间隙锁和行锁。
- **行为**：允许幻读，但不允许脏读和不可重复读。
- **适用场景**：MySQL的默认隔离级别，适用于需要较高数据一致性的场景。

##### **3.4 串行化（SERIALIZABLE）**

- **锁使用**：使用表锁或行锁，确保事务的串行执行。
- **行为**：完全串行化，避免所有并发问题，但性能最低。
- **适用场景**：适用于对数据一致性要求极高，但并发量较低的场景。

#### 4. **间隙锁与行锁的具体实现**

- **间隙锁**：
  - 锁定索引中的一个范围（间隙），而不是特定的记录。
  - 用于防止幻读，确保在事务执行期间，没有其他事务插入新的记录到锁定的范围内。
  - 在可重复读隔离级别下默认启用，但在读已提交隔离级别下，可以通过特定的配置禁用。

- **行锁**：
  - 锁定特定的记录（行），以防止其他事务修改同一行数据。
  - 在所有隔离级别下都可以使用，但在高隔离级别下，行锁的使用频率更高。

#### 5. **表锁的使用场景**

- **表锁**：
  - 锁定整个表，阻止其他事务对表进行修改。
  - 在较低隔离级别下使用较多，但在InnoDB中，表锁主要用于DDL操作，而不是数据操作。

#### 6. **高并发场景下的优化建议**

在高并发场景下，合理配置事务级别和锁机制可以显著提高系统性能：

- **选择适当的隔离级别**：根据业务需求选择合适的事务隔离级别，避免过度使用高隔离级别导致性能下降。
- **优化锁粒度**：尽量使用行锁而不是表锁，减少锁的粒度，提高并发性能。
- **避免长事务**：尽量缩短事务的执行时间，减少锁的持有时间，降低锁冲突的可能性。
- **使用索引**：合理设计索引，减少间隙锁的范围，提高锁的效率。
- **监控和分析**：通过监控工具分析锁的使用情况，识别锁瓶颈，优化数据库性能。

#### 7. **总结**

MySQL中的事务级别和锁机制是密切相关的，不同的事务级别决定了锁的使用策略和数据一致性。理解事务级别与间隙锁、行锁、表锁之间的关系，对于优化数据库的并发控制和性能至关重要。在实际应用中，应根据业务需求和系统负载，合理配置事务级别和锁机制，以实现数据一致性和系统性能的最佳平衡。


=============================================

1. 讲下 hashmap 的扩容机制, 为什么要转红黑树？
2. 为什么 hashmap 会造成死循环？
3. ConcurrentHashMap 是怎么做到线程安全的？
4. volatile 的功能？
5. Happened-before 是什么？
6. CAS 是什么？
7. 说下 AQS 的原理？
8. java 中的线程怎么对应到操作系统上?
9. 具体的业务线程池的参数会考虑哪些因素？
10. NIO 的优势具体体现在哪?


了解论坛类应用的数据库设计
了解电商类的应用的数据库设计
了解 cms 类应用的数据库设计



0.00026450


fa-eercast
fa-address-card


JAVA初级工程师  9k-15k 一般是1-3年的经验
    要求：掌握
   JAVA基础，spring springmvc mybatis servlet restful，webservice，h5 css3 JavaScript jquery angular vue。
   常用的服务器技术：tomcat，apache nginx。
   git  maven redis dubbo zookeeper
   同时还有 多线程，设计模式，JAVA io nio
   网络方面：tcp，udp，netty

JAVA中级工程师 15k-25k  一般是3-5年的经验
   要求：精通
   springcloud dubbo。
   还得熟悉一些中间件技术：分布式技术，rpc技术，缓存，消息系统。
   懂互联网业务，要求有大规模高并发访问web应用的经验。
  熟悉一些虚拟化技术：docker，vmware，openstack。
  深入理解数据结构和算法。（）
  精通设计模式（至少常用的七八种设计模式必须达到精通的水平），就是能用到设计模式到项目中，让项目的代码更规范。

JAVA高级工程师  25k-35k  一般是3-5年
  得会开发，设计还得有领导能力，必须能带领一个团队，分析产品技术设计，负责新功能的技术开发，参与平台的需求分析，业务规划，帮助团队成员解决技术问题。决定技术方向和业务选型。
   有些公司还会要求你了解大数据的一些技术；hadoop impala spark flink主流的大数据框架
  精通jvm内存管理，要会jvm调优
   熟悉分布式常用技术，




JAVA架构师（研发经理）40k-60k 一般是5-10年
    参与微服务架构的设计和落地。要发觉和解决复杂问题，关键技术的公关和改进现有的架构。
就是着重于优化和架构设计的工作。要精通多线程，要有高并发，大数据处理的经验。可能会要求主导过大型高可用，高并发，分布式，自动化的项目经验。熟悉自动化部署技术比如k8s

他是拥有5年Java开发经验，其中3年以上大型系统架构设计经验，以及3年以上的团队管理经验。具有分布式、高并发、高可用、大数据量的系统架构设计以及研发经验，目前正负责注册用户1.5亿，日活300万，日访问量1亿+的手机生活服务平台的絮构设计与研发。同时拥有扎实的技术功底。对dubbo，spring cloud.spring.mybatis,等开源框架均深度阅读过源码。
个人技能
1、精通Java、设计模式、网络编程(Netty)、并发编程、JVM内存管理及调优；
2、精通spring. springMVC.Mybatis，阅读过相关源码并根据需要扩展；
3、精通dubbo、spring cloud (Eureka、Ribbon、Feign、Hystrix、zuul)，阅读过相关源码；
4、精通分布式事务，阅读过2PC、TCC相关组件的源码，设计可靠消息最终一致性方案、最大努力通知方案、saga；
5、精通Mysql，具有sql优化、Mycat 分库分表、"索引优化、性能调优、数据库灾备等丰富的实战经验；
6、精通Redis，具有集群搭建(Twemproxy、Codis、Redis Cluster)，冷热备份，性能调优、数据迁移等实战经验；
7、熟练使用MongoDB，具有集群搭建(副本集、分片集群)，冷热备份、数据迁移、安全管理等实战经验；
8、精通ElasticSearch，熟练使用Solr、Logstash、Beats及Kibana，搭建ELK日志收集；
9、消息中间件：掌握activelMQ. rocketMQ.rabbitlMQ.kafka原理及集群部署
10、负载均衡：熟练使用Nginx (Iengine.Openresty) . Haproxy，LVS、KeepAlived、zookeeper等负载均衡组件；
11、自动化部署:Git、Jenkins、Gradle；
12、容器化部署: docker，具有搭建swarm、mesos、marathon、kubernetes集群并运维经验；
13、自动化运维:熟练使用Saltstack，数据监控(zabbix) ；
14、其他:了解并使用过Hadoop、Hive、Strom等大数据相关技术，使用过其他技术如lua、Go、Python、规则引擎（drools）等；
15、建模工具:PowerDesigner,Rose、visio、等UML建模工具；
16、遵循华为测试规范，功能测试（单元测试、冒烟测试、集成测试、QA测试)性能则试(Jmeter.LoadRunner)、自动化测试(selenium.QTP) ；
17、遵循华为安全体系，代码安全、加密安全、设计安全；
18、遵循华为完善的层级文档规范；



session的复用
前后端分离的原理
线程池执行过程，及各个参数的作用
死锁
new一个对象的过程
动态代理两种
redis
数据库的页分裂
springboot自动装配
springboot动态代理原理
hashmap currenthashmap的区别
eurka的原理，多级缓存
ribbitmq
mvcc
事务
分布式事务管理
mongodb
打破双亲委派
频繁的删除数据
spi
react
netty面试题

c13115711723
La7329322
rocketmq源码
https://www.bilibili.com/video/BV1Hp4y1D7bJ?p=4&vd_source=ce21fb8410865310d1365e9ec297999d



以简历为主
搭建完整项目 若依
springcloud笔记
netty面试题
-xmx1024m -xms10240m -xmn5120 -xxsurvuvirRatio=3
@Transactional()源码


@component
@scheuld
@conditionOnbean   https://blog.csdn.net/kangsa998/article/details/97940187
@restoryision
gpc
websocket
接口跟抽象类的

接口的设计目的，是对类的行为进行约束（更准确的说是一种“有”约束，
因为接口不能规定类不可以有什么行为），也就是提供一种机制，
可以强制要求不同的类具有相同的行为。
它只约束了行为的有无，但不对如何实现行为进行限制。
对“接口为何是约束”的理解，我觉得配合泛型食用效果更佳。
而抽象类的设计目的，是代码复用。
当不同的类具有某些相同的行为(记为行为集合A)，
且其中一部分行为的实现方式一致时（A的非真子集，记为B），
可以让这些类都派生于一个抽象类。在这个抽象类中实现了B，
避免让所有的子类来实现B，这就达到了代码复用的目的。
而A减B的部分，留给各个子类自己实现。
正是因为A-B在这里没有实现，所以抽象类不允许实例化出来（否则当调用到A-B时，无法执行）

一对多，


mybatis   netty  

  springboot源码    https://www.cnblogs.com/java-chen-hao/p/11829344.html#_label1_3
  
  
  
  自测 测试
  类，对象，开闭原则
  session共享或者复用
  mybatis的二级缓存
  单例controller怎么实现高并发
  mysql  spring事务
  ribbitmq防网络抖动 重复消费  将msg存入redis，本地查看是否msg已经存在了
  mybatis批量插入
	多种客户端连接springboot
	登录session和cookie
	过滤器和拦截器的区别
	重定向转发
	安全登录
	前后端交互式出现乱码
